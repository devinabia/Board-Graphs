"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebConnection = void 0;
const client_common_1 = require("@clickhouse/client-common");
const utils_1 = require("../utils");
class WebConnection {
    constructor(params) {
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: params
        });
        Object.defineProperty(this, "defaultAuthHeader", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (params.auth.type === 'JWT') {
            this.defaultAuthHeader = `Bearer ${params.auth.access_token}`;
        }
        else if (params.auth.type === 'Credentials') {
            this.defaultAuthHeader = `Basic ${btoa(`${params.auth.username}:${params.auth.password}`)}`;
        }
        else {
            throw new Error(`Unknown auth type: ${params.auth.type}`);
        }
    }
    async query(params) {
        const query_id = getQueryId(params.query_id);
        const clickhouse_settings = (0, client_common_1.withHttpSettings)(params.clickhouse_settings, this.params.compression.decompress_response);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            role: params.role,
            query_id,
        });
        const response = await this.request({
            body: params.query,
            params,
            searchParams,
        });
        return {
            query_id,
            stream: response.body || new ReadableStream(),
            response_headers: getResponseHeaders(response),
        };
    }
    async exec(params) {
        const result = await this.runExec(params);
        return {
            query_id: result.query_id,
            stream: result.stream || new ReadableStream(),
            response_headers: result.response_headers,
        };
    }
    async command(params) {
        const { stream, query_id, response_headers } = await this.runExec(params);
        if (stream !== null) {
            await stream.cancel();
        }
        return { query_id, response_headers };
    }
    async insert(params) {
        const query_id = getQueryId(params.query_id);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            query: params.query,
            session_id: params.session_id,
            role: params.role,
            query_id,
        });
        const response = await this.request({
            body: params.values,
            params,
            searchParams,
        });
        if (response.body !== null) {
            await response.text(); // drain the response (it's empty anyway)
        }
        return {
            query_id,
            response_headers: getResponseHeaders(response),
        };
    }
    async ping() {
        // ClickHouse /ping endpoint does not support CORS,
        // so we are using a simple SELECT as a workaround
        try {
            const response = await this.request({
                body: null,
                searchParams: (0, client_common_1.toSearchParams)({
                    database: undefined,
                    query: `SELECT 'ping'`,
                    query_id: getQueryId(undefined),
                }),
                method: 'GET',
            });
            if (response.body !== null) {
                await response.body.cancel();
            }
            return { success: true };
        }
        catch (error) {
            if (error instanceof Error) {
                return {
                    success: false,
                    error,
                };
            }
            throw error; // should never happen
        }
    }
    async close() {
        return;
    }
    async request({ body, params, searchParams, pathname, method, }) {
        const url = (0, client_common_1.transformUrl)({
            url: this.params.url,
            pathname,
            searchParams,
        }).toString();
        const abortController = new AbortController();
        let isTimedOut = false;
        const timeout = setTimeout(() => {
            isTimedOut = true;
            abortController.abort();
        }, this.params.request_timeout);
        let isAborted = false;
        if (params?.abort_signal !== undefined) {
            params.abort_signal.onabort = () => {
                isAborted = true;
                abortController.abort();
            };
        }
        try {
            const headers = (0, client_common_1.withCompressionHeaders)({
                headers: this.defaultHeadersWithOverride(params),
                // It is not currently working as expected in all major browsers
                enable_request_compression: false,
                enable_response_compression: this.params.compression.decompress_response,
            });
            // avoiding "fetch called on an object that does not implement interface Window" error
            const fetchFn = this.params.fetch ?? fetch;
            const response = await fetchFn(url, {
                body,
                headers,
                keepalive: this.params.keep_alive.enabled,
                method: method ?? 'POST',
                signal: abortController.signal,
            });
            clearTimeout(timeout);
            if ((0, client_common_1.isSuccessfulResponse)(response.status)) {
                return response;
            }
            else {
                return Promise.reject((0, client_common_1.parseError)(await (0, utils_1.getAsText)(response.body || new ReadableStream())));
            }
        }
        catch (err) {
            clearTimeout(timeout);
            if (isAborted) {
                return Promise.reject(new Error('The user aborted a request.'));
            }
            if (isTimedOut) {
                return Promise.reject(new Error('Timeout error.'));
            }
            if (err instanceof Error) {
                // maybe it's a ClickHouse error
                return Promise.reject((0, client_common_1.parseError)(err));
            }
            // shouldn't happen
            throw err;
        }
    }
    async runExec(params) {
        const query_id = getQueryId(params.query_id);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            role: params.role,
            query_id,
        });
        const response = await this.request({
            body: params.query,
            params,
            searchParams,
        });
        return {
            stream: response.body,
            response_headers: getResponseHeaders(response),
            query_id,
        };
    }
    defaultHeadersWithOverride(params) {
        let authHeader;
        if ((0, client_common_1.isJWTAuth)(params?.auth)) {
            authHeader = `Bearer ${params?.auth.access_token}`;
        }
        else if ((0, client_common_1.isCredentialsAuth)(params?.auth)) {
            authHeader = `Basic ${btoa(`${params?.auth.username}:${params?.auth.password}`)}`;
        }
        else {
            authHeader = this.defaultAuthHeader;
        }
        return {
            // Custom HTTP headers from the client configuration
            ...(this.params.http_headers ?? {}),
            // Custom HTTP headers for this particular request; it will override the client configuration with the same keys
            ...(params?.http_headers ?? {}),
            Authorization: authHeader,
        };
    }
}
exports.WebConnection = WebConnection;
function getQueryId(query_id) {
    return query_id || crypto.randomUUID();
}
function getResponseHeaders(response) {
    const headers = {};
    response.headers.forEach((value, key) => {
        headers[key] = value;
    });
    return headers;
}
//# sourceMappingURL=web_connection.js.map